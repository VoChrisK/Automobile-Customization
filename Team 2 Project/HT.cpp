/*==============================
HT.cpp
Implementation file for HashTable.H class functions.
==============================*/

#include "HT.h"

/*==============================
HT::HT
Constructor.
==============================*/

HT::HT()
{
	for (int i = 0; i < 31; i++)
	{
		fill[i] = 0;

		for (int j = 0; j < 3; j++)
			bucket[i][j] = NULL;
	}

	total = 0;
}

/*==============================
HT::~HT
Destructor. Deletes all nodes in the hash table.
==============================*/

HT::~HT()
{
	for (int i = 0; i < 31; i++)
	{
		for (int j = 0; j < 3; j++)
			delete bucket[i][j];
	}
}

/*==============================
HT::insert
Inserts a stock object into the hash table. The object is sorted
by a hash key generated by its unique data field. It is placed first
in the buckets if the buckets are empty, otherwise it is placed in the
next available bucket in the case of collisions.
==============================*/

void HT::insert(Stock_Data *input)
{
	int hash = gethash(input->ticker);

	if (fill[hash] == 0)
	{
		bucket[hash][0] = input;
		fill[hash]++;
		total++;
	}

	else
	{
		int j = 0;

		while (bucket[hash][j])
			j++;

		bucket[hash][j] = input;
		fill[hash]++;
		total++;
        
        if(j > 2)
        {
            cout << "Bucket is Full! Cannot enter data into hash table." << endl;
            return;
        }
	}
}

/*==============================
HT::gethash
Generates a hash key for sorting objects when
inserting them into the hash table.
The hash key is the sum of the ascii values of the ticker,
followed by a modulus operation by 31.
==============================*/

int HT::gethash(string key)
{
	int premod = 0;
	int length = key.length();

	for (int i = 0; i < length; i++)
		premod += key[i];

	int hash = premod % 31;
	return hash;
}

/*==============================
HT::search
Searches the hash table for a stock object whose ticker
matches that of the user-input string. Prints the info of
the object upon successful match and returns true. Returns
false otherwise.
==============================*/

Stock_Data *HT::search(string target)
{
	bool found;
	int hash = gethash(target);
	Stock_Data *hit = new Stock_Data;

	for (int i = 0; i < TABLE_WIDTH && bucket[hash][i]; i++)
	{
		if (target == bucket[hash][i]->ticker)
		{
			cout << endl << "Search successful:" << endl << endl;
			cout
				<< "Ticker: " << bucket[hash][i]->ticker << endl
				<< "Name:   " << bucket[hash][i]->name << endl
				<< "Value:  " << bucket[hash][i]->value << endl
				<< "Volume: " << bucket[hash][i]->volume << endl;
			bucket[hash][i]->searchcount++;
			hit = bucket[hash][i];
			return hit;
		}
	}
	return NULL;
}

/*==============================
HT::print
Prints the contents of every single cell in
the hash table in order of bucket and location.
==============================*/

void HT::print()
{
	for (int i = 0; i < TABLE_LENGTH; i++)
	{
		cout << "Bucket " << i << ": " << endl;

		for (int j = 0; j < TABLE_WIDTH; j++)
		{
			cout << "          ";
			cout << "Location " << j << ": ";
			if (bucket[i][j])
			{
				cout << bucket[i][j]->ticker << ", "
					<< bucket[i][j]->name << endl;
			}
			else
				cout << "empty" << endl;
		}
	}
}

/*==============================
HT::display
Displays every entry stored in the hash table.
==============================*/

void HT::display()
{
	for (int i = 0; i < TABLE_LENGTH; i++)
	{
		for (int j = 0; j < TABLE_WIDTH; j++)
		{
			if (bucket[i][j])
			{
				cout << bucket[i][j]->ticker << endl;
			}
		}
	}
}

/*==============================
HT::stats
Displays a few basic statistics of the hash table, including
total entries, load factor, collisions, and number of full buckets.
==============================*/

void HT::stats()
{
	int possible = TABLE_LENGTH * TABLE_WIDTH;
	double loadfactor = (double)total / (double)possible;
	int collisions = 0;
	int fullbuckets = 0;

	for (int i = 0; i < TABLE_LENGTH; i++)
	{
		if (fill[i] > 1)
			collisions++;
		if (fill[i] == TABLE_WIDTH)
			fullbuckets++;
	}

	cout << endl << setw(30) << left << "Total number of entries: " << total;
	cout << endl << setw(30) << "Number of collisions: " << collisions;
	cout << endl << setw(30) << "Load factor: " << setprecision(3) << loadfactor * 100 << "%";
	cout << endl << setw(30) << "Number of full buckets: " << fullbuckets << endl;
}

/*==============================
HT::deletion
Deletes a stock data in the hash table. 
==============================*/
bool HT::deletion(string target)
{
	int hash = gethash(target);

	for (int i = 0; i < TABLE_WIDTH && bucket[hash][i]; i++)
	{
		if (target == bucket[hash][i]->ticker)
		{
			cout << endl << "Target data found..." << endl << endl;
			for (int j = i; j < TABLE_WIDTH - 1; j++)
				bucket[hash][j] = bucket[hash][j + 1];
			bucket[hash][TABLE_WIDTH-1] = NULL;
			total--;
			return true;
		}
	}
	return false;
}